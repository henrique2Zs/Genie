import { Injectable } from '@angular/core';
import { Card } from '../class/card';
import { Firestore, setDoc, doc, getDoc, increment } from '@angular/fire/firestore';
import { updateDoc } from '@firebase/firestore';

@Injectable({
  providedIn: 'root'
})
export class CardsService {

  numsBuilt: number[] = new Array<number>();
  numsSent: number[] = new Array<number>();
  numsLiked: number[] = new Array<number>();
  numsWished: number[] = new Array<number>();
  // Variables generated by app and hide to user
  private numsSelectedToshow: number[] = new Array<number>();
  private numsReceived: number[] = new Array<number>();
  private pointerReceived = 0
  private lastNumberShowed = 1

  collectionBuilt: Card[] = new Array<Card>();
  collectionSent: Card[] = new Array<Card>();
  collectionLiked: Card[] = new Array<Card>();
  collectionSellection: Card[] = new Array<Card>();
  collectionWished: Card[] = new Array<Card>();
  allCardsArray: number[];

  allCardsMap: Map<number, Card> = new Map<number, Card>();
  selectedCard: Card;

  collSelectionReady: number;
  
  cardConverter = {
    toFirestore: (card) => {
      return {
        title: card.title,
        src: card.src,
        link: card.link,
        description: card.description
      };
    },
    fromFirestore: (snapshot, options) => {
      const data = snapshot.data(options);
      return new Card(data.id, data.link, data.src, data.title, data.description);
    }
  }


  ngOnInit() { }

  constructor(private firestore: Firestore) {
    // Inicio datos de pruebas
    this.numsBuilt.push(1)
    this.numsBuilt.push(7)
    this.numsBuilt.push(8)
    this.numsBuilt.push(9)
    this.numsLiked.push(10)
    //this.numsSent.push(3) The service cardXContacts must to do this operation
    this.numsWished.push(4)
    this.numsReceived.push(6)
    // Fin datos de prueba

    this.allCardsArray = this.buildArrayFromNumbersCard()
    this.buildAllCardsMap(this.allCardsArray)
    this.buildSelectionCardFromDB()
    this.getCardsSellection()
  }
  /* 
  * Recopile all numbers cards in a array to be used to build the main map
  * with all numbers card and those Cards
  */
  private buildArrayFromNumbersCard(): Array<number> {
    this.allCardsArray = new Array<number>();
    for (let num of this.numsBuilt) {
      if (!this.allCardsArray.includes(num))
        this.allCardsArray.push(num)
    }
    for (let num of this.numsLiked) {
      if (!this.allCardsArray.includes(num))
        this.allCardsArray.push(num)
    }
    for (let num of this.numsReceived) {
      if (!this.allCardsArray.includes(num))
        this.allCardsArray.push(num)
    }
    for (let num of this.numsSent) {
      if (!this.allCardsArray.includes(num))
        this.allCardsArray.push(num)
    }
    for (let num of this.numsWished) {
      if (!this.allCardsArray.includes(num))
        this.allCardsArray.push(num)
    }
    return this.allCardsArray
  }

  private buildAllCardsMap(arraysNumCards: Array<number>) {
    for (let num of arraysNumCards) {
      this.getCardOnDB(num).then(
        (card: Card) => {
          card.liked = this.numsLiked.includes(num);
          card.inWishList = this.numsWished.includes(num);
          this.allCardsMap.set(card.id, card); 
          } 
        , () =>console.log("Fail to get the card number: " + num)
      );
    }
  }

  public async addProductDB(card: Card) {
    let lastIdcard: any;
    try {
      let docRef;
      ({ docRef, lastIdcard } = await this.getLastIdCard());       
      setDoc(doc(this.firestore, "/cards", (lastIdcard.count + 1).toString()).withConverter(this.cardConverter), card)
        .then(() => {console.log("CardUp guardado con Ã©xito");
                    updateDoc(docRef, 'count', increment(1))}
                    , () => console.error("Card rejetado y no guardado"));
    } catch (error) {
      console.error("Error en get count Cards on addProcductDB" + error)
    }
    }

  private async getLastIdCard() {
    let lastIdcard;
    const docRef = doc(this.firestore, "cards", "count");
    const docSnap = await getDoc(docRef);
    if (docSnap.exists()) {
      lastIdcard = docSnap.data();
    } else {
      // doc.data() will be undefined in this case
      console.error("No such document! " + "count");
  }
    return { docRef, lastIdcard };
  }

  public async getCardOnDB(num: number): Promise<Card> {
    let card;    
    const docRef = doc(this.firestore, "cards", num.toString()).withConverter(this.cardConverter)      
    const docSnap = await getDoc(docRef).then( (docSnap) => {
      if (docSnap.exists()) {
        card = docSnap.data();                      
        card.id = parseInt(docRef.id)          
      } else {
        // doc.data() will be undefined in this case
        console.error("No such document! " + num.toString())
      };        
    })
    return card 
  }

  /*
  * Intent to pull a card from the database that this user is not the autor 
  * neither is inside from any list made by him.
  * However the result include those numbers cards send by a contact that is
  * in touch calling the method @selectReceivedcards. Finally the result is
  * ordered by id's cards to ramdomize and don't have a standard like first those 
  * received and after those from DB's suggest
  * The number tried could not exist because was censored or the end of all 
  * created card has reached.
  */
  public async buildSelectionCardFromDB(): Promise<void> {    
    let lastIdcard;
    let docRef;
    ({ docRef, lastIdcard } = await this.getLastIdCard());  
    let endOfList = lastIdcard.count
    this.numsSelectedToshow = new Array<number>();
    this.selectReceivedcards()
    this.collSelectionReady = 0;
    // This block "while" is necessary because on block "for" can not find some number
    while (this.lastNumberShowed <= endOfList && this.numsSelectedToshow.length <= 10) {
      for (this.lastNumberShowed; endOfList >= this.lastNumberShowed; this.lastNumberShowed++) {
        this.numsSelectedToshow.push(this.lastNumberShowed);
        if (!this.allCardsMap.has(this.lastNumberShowed)) {
          this.collSelectionReady ++;
          this.getCardOnDB(this.lastNumberShowed).then(
            (card: Card) => {
              card.liked = this.numsLiked.includes(card.id);
              card.inWishList = this.numsWished.includes(card.id);
              this.allCardsMap.set(card.id, card); }              
              , () =>console.log("Fail to get the card number: " + this.lastNumberShowed))
              .finally( () => this.collSelectionReady --)
          
        }
      }
    }
    this.numsSelectedToshow.sort()    
    //this.collSelectionReady = new Promise<number>(() => requestsTowait)
  }

  /*
  * Put 5 numbers inside de collection that is showed in the Selection's page
  */
  private selectReceivedcards() {
    let length = this.numsReceived.length
    let startIndex = this.pointerReceived
    let diffLengthPointer = length - startIndex
    let endIndex = diffLengthPointer < 5 ? startIndex + diffLengthPointer : startIndex + 4
    this.numsSelectedToshow = this.numsReceived.slice(startIndex, endIndex)
    this.pointerReceived = endIndex
  }

  public getCards(): Map<number, Card> {
    return this.allCardsMap;
  }

  public getAcard(num: number): Card {
    return this.allCardsMap.get(num)
  }

  public put(card: Card): void {    
    this.numsBuilt.push(card.id)
    this.getCardsBuilt()    
  }

  addInWishList(cardId: number) {
    this.numsWished.push(cardId)
    let card = this.getCards().get(cardId)
    card.inWishList = true
  }

  quitInWishList(cardId: number) {
    let arrayTemp = this.numsWished.filter(n => n != cardId)
    this.numsWished = arrayTemp
    let card = this.getCards().get(cardId)
    card.inWishList = false
  }

  addInLiked(cardId: number) {
    this.numsLiked.push(cardId)
    let card = this.getCards().get(cardId)
    card.liked = true
  }

  quitInLiked(cardId: number) {
    let arrayTemp = this.numsLiked.filter(n => n != cardId)
    this.numsLiked = arrayTemp
    let card = this.getCards().get(cardId)
    card.liked = false
  }

  /*
  * All this sequence of methods below getCards{map's name} are used by 
  * those respective page with the same name.
  * They are lazy maps methods because is called when it's needed.
  */
  public getCardsBuilt(): Card[] {
    this.collectionBuilt = this.buildCards(this.numsBuilt);
    return this.collectionBuilt
  }
  public getCardsSent(): Card[] {
    this.collectionSent = this.buildCards(this.numsSent);
    return this.collectionSent
  }
  public getCardsLiked(): Card[] {
    this.collectionLiked = this.buildCards(this.numsLiked);
    return this.collectionLiked
  }
  public getCardsSellection(): Card[] {   
    this.collectionSellection = this.buildCards(this.numsSelectedToshow);
    return this.collectionSellection
  }
  public getCardsWished(): Card[] {
    this.collectionWished = this.buildCards(this.numsWished);
    return this.collectionWished
  }

  /*
  * Refresh arrays of cards from arrays of number cards inside this service
  */
  private buildCards(cardsnum: number[]): Card[] {
    let card: Card
    let collectionTemp = new Array<Card>()
    for (let num of cardsnum) {
      card = this.allCardsMap.get(num)
      collectionTemp.push(card)
    }
    return collectionTemp

  }
}